/* tslint:disable */
/* eslint-disable */
/**
 * Quickstart
 * | Link | | --- | | [Get Order](/docs/ultra/get-order) | | [Execute Order](/docs/ultra/execute-order) | 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { BalancesAddressGet200ResponseValue } from '../types';
// @ts-ignore
import type { ExecutePost200Response } from '../types';
// @ts-ignore
import type { ExecutePost400Response } from '../types';
// @ts-ignore
import type { ExecutePostRequest } from '../types';
// @ts-ignore
import type { HoldingsResponse } from '../types';
// @ts-ignore
import type { MintInformation } from '../types';
// @ts-ignore
import type { NativeHoldingsResponse } from '../types';
// @ts-ignore
import type { OrderGet200Response } from '../types';
// @ts-ignore
import type { OrderGet400Response } from '../types';
// @ts-ignore
import type { OrderGet500Response } from '../types';
// @ts-ignore
import type { OrderRoutersGet200ResponseInner } from '../types';
// @ts-ignore
import type { ShieldGet200Response } from '../types';
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Request for token balances of an account 
         * @summary balances
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        balancesAddressGet: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('balancesAddressGet', 'address', address)
            const localVarPath = `/balances/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute the signed transaction and get the execution status 
         * @summary execute
         * @param {ExecutePostRequest} [executePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePost: async (executePostRequest?: ExecutePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/execute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request for token balances of an account including token account information 
         * @summary holdings
         * @param {string} address The wallet address to get holdings for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holdingsAddressGet: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('holdingsAddressGet', 'address', address)
            const localVarPath = `/holdings/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request for native SOL holdings only, without other tokens 
         * @summary holdings (native)
         * @param {string} address The wallet address to get native SOL balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holdingsAddressNativeGet: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('holdingsAddressNativeGet', 'address', address)
            const localVarPath = `/holdings/{address}/native`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request for a base64-encoded unsigned swap transaction to be used in `POST /ultra/v1/execute` 
         * @summary order
         * @param {string} inputMint 
         * @param {string} outputMint 
         * @param {string} amount 
         * @param {string} [taker] 
         * @param {string} [receiver] - The public key of the account that will receive the output tokens - If not provided, the output tokens will be sent to the taker like default - It expects an account (NOT a token account) - If the output is non-SOL tokens, it only transfers to ATAs (not token accounts) - If the destination token account is not initialized, an additional create ATA instruction will be added to the transaction - If the output is SOL, it will transfer native SOL directly to the receiver account - It does not support destination WSOL token account 
         * @param {string} [payer] - The public key of an account that will be used to cover \&#39;gas-related\&#39; fees on behalf of the taker - Gas related fees such as signature fees, priority fees and rent. Note that enabling this may result in different routing decisions. - When &#x60;payer&#x60; is passed in, &#x60;closeAuthority&#x60; is required - Refer to [Integrator Payer](/docs/ultra/add-payer) for more details 
         * @param {string} [closeAuthority] - The public key of an account to set as the close authority of ATAs created during the swap transaction. Only applies to non-wSOL ATAs that persist beyond the execution of the transaction. - When &#x60;payer&#x60; is passed in, &#x60;closeAuthority&#x60; is required - If the &#x60;closeAuthority&#x3D;&#x3D;taker&#x60;, the &#x60;taker&#x60; is the close authority and no additional instructions will be added - If the &#x60;closeAuthority!&#x3D;&#x3D;taker&#x60;, the &#x60;closeAuthority&#x60; will be set by adding an instruction to the transaction to set the close authority 
         * @param {string} [referralAccount] - Refer to [Integrator Fees](/docs/ultra/add-fees-to-ultra) for more details 
         * @param {number} [referralFee] - Refer to [Integrator Fees](/docs/ultra/add-fees-to-ultra) for more details 
         * @param {OrderGetExcludeRoutersEnum} [excludeRouters] 
         * @param {string} [excludeDexes] - [Full list of DEXes here](https://lite-api.jup.ag/swap/v1/program-id-to-label), for example: &#x60;excludeDexes&#x3D;Raydium,Orca+V2,Meteora+DLMM&#x60; - **Important**: This only excludes DEXes on the Iris router, does not apply to other routers - For example:   - **Exclude** Raydium: &#x60;excludeRouters&#x3D;&lt;all-except-Iris&gt;&#x60; and &#x60;excludeDexes&#x3D;Raydium&#x60;   - **Only include** Meteora DLMM: &#x60;excludeRouters&#x3D;&lt;all-except-Iris&gt;&#x60; and &#x60;excludeDexes&#x3D;&lt;all-except-MeteoraDLMM&gt;&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGet: async (inputMint: string, outputMint: string, amount: string, taker?: string, receiver?: string, payer?: string, closeAuthority?: string, referralAccount?: string, referralFee?: number, excludeRouters?: OrderGetExcludeRoutersEnum, excludeDexes?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inputMint' is not null or undefined
            assertParamExists('orderGet', 'inputMint', inputMint)
            // verify required parameter 'outputMint' is not null or undefined
            assertParamExists('orderGet', 'outputMint', outputMint)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('orderGet', 'amount', amount)
            const localVarPath = `/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (inputMint !== undefined) {
                localVarQueryParameter['inputMint'] = inputMint;
            }

            if (outputMint !== undefined) {
                localVarQueryParameter['outputMint'] = outputMint;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (taker !== undefined) {
                localVarQueryParameter['taker'] = taker;
            }

            if (receiver !== undefined) {
                localVarQueryParameter['receiver'] = receiver;
            }

            if (payer !== undefined) {
                localVarQueryParameter['payer'] = payer;
            }

            if (closeAuthority !== undefined) {
                localVarQueryParameter['closeAuthority'] = closeAuthority;
            }

            if (referralAccount !== undefined) {
                localVarQueryParameter['referralAccount'] = referralAccount;
            }

            if (referralFee !== undefined) {
                localVarQueryParameter['referralFee'] = referralFee;
            }

            if (excludeRouters !== undefined) {
                localVarQueryParameter['excludeRouters'] = excludeRouters;
            }

            if (excludeDexes !== undefined) {
                localVarQueryParameter['excludeDexes'] = excludeDexes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request for the list of routers available in the routing engine of Ultra, which is [Juno](/docs/routing#juno-liquidity-engine) 
         * @summary routers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderRoutersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/routers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request a search by token\'s symbol, name or mint address 
         * @summary search
         * @param {string} query - Search for a token and its information by its symbol, name or mint address - Comma-separate to search for multiple - Limit to 100 mint addresses in query - Default to 20 mints in response when searching via symbol or name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGet: async (query: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchGet', 'query', query)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request for token information and warnings of mints 
         * @summary shield
         * @param {string} mints - Comma separated list of mints to get information for 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldGet: async (mints: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mints' is not null or undefined
            assertParamExists('shieldGet', 'mints', mints)
            const localVarPath = `/shield`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mints !== undefined) {
                localVarQueryParameter['mints'] = mints;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Request for token balances of an account 
         * @summary balances
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async balancesAddressGet(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: BalancesAddressGet200ResponseValue; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balancesAddressGet(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.balancesAddressGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Execute the signed transaction and get the execution status 
         * @summary execute
         * @param {ExecutePostRequest} [executePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePost(executePostRequest?: ExecutePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePost(executePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.executePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request for token balances of an account including token account information 
         * @summary holdings
         * @param {string} address The wallet address to get holdings for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async holdingsAddressGet(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HoldingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.holdingsAddressGet(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.holdingsAddressGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request for native SOL holdings only, without other tokens 
         * @summary holdings (native)
         * @param {string} address The wallet address to get native SOL balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async holdingsAddressNativeGet(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NativeHoldingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.holdingsAddressNativeGet(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.holdingsAddressNativeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request for a base64-encoded unsigned swap transaction to be used in `POST /ultra/v1/execute` 
         * @summary order
         * @param {string} inputMint 
         * @param {string} outputMint 
         * @param {string} amount 
         * @param {string} [taker] 
         * @param {string} [receiver] - The public key of the account that will receive the output tokens - If not provided, the output tokens will be sent to the taker like default - It expects an account (NOT a token account) - If the output is non-SOL tokens, it only transfers to ATAs (not token accounts) - If the destination token account is not initialized, an additional create ATA instruction will be added to the transaction - If the output is SOL, it will transfer native SOL directly to the receiver account - It does not support destination WSOL token account 
         * @param {string} [payer] - The public key of an account that will be used to cover \&#39;gas-related\&#39; fees on behalf of the taker - Gas related fees such as signature fees, priority fees and rent. Note that enabling this may result in different routing decisions. - When &#x60;payer&#x60; is passed in, &#x60;closeAuthority&#x60; is required - Refer to [Integrator Payer](/docs/ultra/add-payer) for more details 
         * @param {string} [closeAuthority] - The public key of an account to set as the close authority of ATAs created during the swap transaction. Only applies to non-wSOL ATAs that persist beyond the execution of the transaction. - When &#x60;payer&#x60; is passed in, &#x60;closeAuthority&#x60; is required - If the &#x60;closeAuthority&#x3D;&#x3D;taker&#x60;, the &#x60;taker&#x60; is the close authority and no additional instructions will be added - If the &#x60;closeAuthority!&#x3D;&#x3D;taker&#x60;, the &#x60;closeAuthority&#x60; will be set by adding an instruction to the transaction to set the close authority 
         * @param {string} [referralAccount] - Refer to [Integrator Fees](/docs/ultra/add-fees-to-ultra) for more details 
         * @param {number} [referralFee] - Refer to [Integrator Fees](/docs/ultra/add-fees-to-ultra) for more details 
         * @param {OrderGetExcludeRoutersEnum} [excludeRouters] 
         * @param {string} [excludeDexes] - [Full list of DEXes here](https://lite-api.jup.ag/swap/v1/program-id-to-label), for example: &#x60;excludeDexes&#x3D;Raydium,Orca+V2,Meteora+DLMM&#x60; - **Important**: This only excludes DEXes on the Iris router, does not apply to other routers - For example:   - **Exclude** Raydium: &#x60;excludeRouters&#x3D;&lt;all-except-Iris&gt;&#x60; and &#x60;excludeDexes&#x3D;Raydium&#x60;   - **Only include** Meteora DLMM: &#x60;excludeRouters&#x3D;&lt;all-except-Iris&gt;&#x60; and &#x60;excludeDexes&#x3D;&lt;all-except-MeteoraDLMM&gt;&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderGet(inputMint: string, outputMint: string, amount: string, taker?: string, receiver?: string, payer?: string, closeAuthority?: string, referralAccount?: string, referralFee?: number, excludeRouters?: OrderGetExcludeRoutersEnum, excludeDexes?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderGet(inputMint, outputMint, amount, taker, receiver, payer, closeAuthority, referralAccount, referralFee, excludeRouters, excludeDexes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.orderGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request for the list of routers available in the routing engine of Ultra, which is [Juno](/docs/routing#juno-liquidity-engine) 
         * @summary routers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderRoutersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrderRoutersGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderRoutersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.orderRoutersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request a search by token\'s symbol, name or mint address 
         * @summary search
         * @param {string} query - Search for a token and its information by its symbol, name or mint address - Comma-separate to search for multiple - Limit to 100 mint addresses in query - Default to 20 mints in response when searching via symbol or name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchGet(query: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MintInformation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGet(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.searchGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request for token information and warnings of mints 
         * @summary shield
         * @param {string} mints - Comma separated list of mints to get information for 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shieldGet(mints: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShieldGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shieldGet(mints, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.shieldGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Request for token balances of an account 
         * @summary balances
         * @param {DefaultApiBalancesAddressGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        balancesAddressGet(requestParameters: DefaultApiBalancesAddressGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: BalancesAddressGet200ResponseValue; }> {
            return localVarFp.balancesAddressGet(requestParameters.address, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute the signed transaction and get the execution status 
         * @summary execute
         * @param {DefaultApiExecutePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePost(requestParameters: DefaultApiExecutePostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ExecutePost200Response> {
            return localVarFp.executePost(requestParameters.executePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Request for token balances of an account including token account information 
         * @summary holdings
         * @param {DefaultApiHoldingsAddressGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holdingsAddressGet(requestParameters: DefaultApiHoldingsAddressGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<HoldingsResponse> {
            return localVarFp.holdingsAddressGet(requestParameters.address, options).then((request) => request(axios, basePath));
        },
        /**
         * Request for native SOL holdings only, without other tokens 
         * @summary holdings (native)
         * @param {DefaultApiHoldingsAddressNativeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holdingsAddressNativeGet(requestParameters: DefaultApiHoldingsAddressNativeGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<NativeHoldingsResponse> {
            return localVarFp.holdingsAddressNativeGet(requestParameters.address, options).then((request) => request(axios, basePath));
        },
        /**
         * Request for a base64-encoded unsigned swap transaction to be used in `POST /ultra/v1/execute` 
         * @summary order
         * @param {DefaultApiOrderGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGet(requestParameters: DefaultApiOrderGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrderGet200Response> {
            return localVarFp.orderGet(requestParameters.inputMint, requestParameters.outputMint, requestParameters.amount, requestParameters.taker, requestParameters.receiver, requestParameters.payer, requestParameters.closeAuthority, requestParameters.referralAccount, requestParameters.referralFee, requestParameters.excludeRouters, requestParameters.excludeDexes, options).then((request) => request(axios, basePath));
        },
        /**
         * Request for the list of routers available in the routing engine of Ultra, which is [Juno](/docs/routing#juno-liquidity-engine) 
         * @summary routers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderRoutersGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<OrderRoutersGet200ResponseInner>> {
            return localVarFp.orderRoutersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Request a search by token\'s symbol, name or mint address 
         * @summary search
         * @param {DefaultApiSearchGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGet(requestParameters: DefaultApiSearchGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MintInformation>> {
            return localVarFp.searchGet(requestParameters.query, options).then((request) => request(axios, basePath));
        },
        /**
         * Request for token information and warnings of mints 
         * @summary shield
         * @param {DefaultApiShieldGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shieldGet(requestParameters: DefaultApiShieldGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ShieldGet200Response> {
            return localVarFp.shieldGet(requestParameters.mints, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for balancesAddressGet operation in DefaultApi.
 * @export
 * @interface DefaultApiBalancesAddressGetRequest
 */
export interface DefaultApiBalancesAddressGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiBalancesAddressGet
     */
    readonly address: string
}

/**
 * Request parameters for executePost operation in DefaultApi.
 * @export
 * @interface DefaultApiExecutePostRequest
 */
export interface DefaultApiExecutePostRequest {
    /**
     * 
     * @type {ExecutePostRequest}
     * @memberof DefaultApiExecutePost
     */
    readonly executePostRequest?: ExecutePostRequest
}

/**
 * Request parameters for holdingsAddressGet operation in DefaultApi.
 * @export
 * @interface DefaultApiHoldingsAddressGetRequest
 */
export interface DefaultApiHoldingsAddressGetRequest {
    /**
     * The wallet address to get holdings for
     * @type {string}
     * @memberof DefaultApiHoldingsAddressGet
     */
    readonly address: string
}

/**
 * Request parameters for holdingsAddressNativeGet operation in DefaultApi.
 * @export
 * @interface DefaultApiHoldingsAddressNativeGetRequest
 */
export interface DefaultApiHoldingsAddressNativeGetRequest {
    /**
     * The wallet address to get native SOL balance for
     * @type {string}
     * @memberof DefaultApiHoldingsAddressNativeGet
     */
    readonly address: string
}

/**
 * Request parameters for orderGet operation in DefaultApi.
 * @export
 * @interface DefaultApiOrderGetRequest
 */
export interface DefaultApiOrderGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiOrderGet
     */
    readonly inputMint: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiOrderGet
     */
    readonly outputMint: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiOrderGet
     */
    readonly amount: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiOrderGet
     */
    readonly taker?: string

    /**
     * - The public key of the account that will receive the output tokens - If not provided, the output tokens will be sent to the taker like default - It expects an account (NOT a token account) - If the output is non-SOL tokens, it only transfers to ATAs (not token accounts) - If the destination token account is not initialized, an additional create ATA instruction will be added to the transaction - If the output is SOL, it will transfer native SOL directly to the receiver account - It does not support destination WSOL token account 
     * @type {string}
     * @memberof DefaultApiOrderGet
     */
    readonly receiver?: string

    /**
     * - The public key of an account that will be used to cover \&#39;gas-related\&#39; fees on behalf of the taker - Gas related fees such as signature fees, priority fees and rent. Note that enabling this may result in different routing decisions. - When &#x60;payer&#x60; is passed in, &#x60;closeAuthority&#x60; is required - Refer to [Integrator Payer](/docs/ultra/add-payer) for more details 
     * @type {string}
     * @memberof DefaultApiOrderGet
     */
    readonly payer?: string

    /**
     * - The public key of an account to set as the close authority of ATAs created during the swap transaction. Only applies to non-wSOL ATAs that persist beyond the execution of the transaction. - When &#x60;payer&#x60; is passed in, &#x60;closeAuthority&#x60; is required - If the &#x60;closeAuthority&#x3D;&#x3D;taker&#x60;, the &#x60;taker&#x60; is the close authority and no additional instructions will be added - If the &#x60;closeAuthority!&#x3D;&#x3D;taker&#x60;, the &#x60;closeAuthority&#x60; will be set by adding an instruction to the transaction to set the close authority 
     * @type {string}
     * @memberof DefaultApiOrderGet
     */
    readonly closeAuthority?: string

    /**
     * - Refer to [Integrator Fees](/docs/ultra/add-fees-to-ultra) for more details 
     * @type {string}
     * @memberof DefaultApiOrderGet
     */
    readonly referralAccount?: string

    /**
     * - Refer to [Integrator Fees](/docs/ultra/add-fees-to-ultra) for more details 
     * @type {number}
     * @memberof DefaultApiOrderGet
     */
    readonly referralFee?: number

    /**
     * 
     * @type {'iris' | 'jupiterz' | 'dflow' | 'okx'}
     * @memberof DefaultApiOrderGet
     */
    readonly excludeRouters?: OrderGetExcludeRoutersEnum

    /**
     * - [Full list of DEXes here](https://lite-api.jup.ag/swap/v1/program-id-to-label), for example: &#x60;excludeDexes&#x3D;Raydium,Orca+V2,Meteora+DLMM&#x60; - **Important**: This only excludes DEXes on the Iris router, does not apply to other routers - For example:   - **Exclude** Raydium: &#x60;excludeRouters&#x3D;&lt;all-except-Iris&gt;&#x60; and &#x60;excludeDexes&#x3D;Raydium&#x60;   - **Only include** Meteora DLMM: &#x60;excludeRouters&#x3D;&lt;all-except-Iris&gt;&#x60; and &#x60;excludeDexes&#x3D;&lt;all-except-MeteoraDLMM&gt;&#x60; 
     * @type {string}
     * @memberof DefaultApiOrderGet
     */
    readonly excludeDexes?: string
}

/**
 * Request parameters for searchGet operation in DefaultApi.
 * @export
 * @interface DefaultApiSearchGetRequest
 */
export interface DefaultApiSearchGetRequest {
    /**
     * - Search for a token and its information by its symbol, name or mint address - Comma-separate to search for multiple - Limit to 100 mint addresses in query - Default to 20 mints in response when searching via symbol or name 
     * @type {string}
     * @memberof DefaultApiSearchGet
     */
    readonly query: string
}

/**
 * Request parameters for shieldGet operation in DefaultApi.
 * @export
 * @interface DefaultApiShieldGetRequest
 */
export interface DefaultApiShieldGetRequest {
    /**
     * - Comma separated list of mints to get information for 
     * @type {string}
     * @memberof DefaultApiShieldGet
     */
    readonly mints: string
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Request for token balances of an account 
     * @summary balances
     * @param {DefaultApiBalancesAddressGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public balancesAddressGet(requestParameters: DefaultApiBalancesAddressGetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).balancesAddressGet(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute the signed transaction and get the execution status 
     * @summary execute
     * @param {DefaultApiExecutePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public executePost(requestParameters: DefaultApiExecutePostRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).executePost(requestParameters.executePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request for token balances of an account including token account information 
     * @summary holdings
     * @param {DefaultApiHoldingsAddressGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public holdingsAddressGet(requestParameters: DefaultApiHoldingsAddressGetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).holdingsAddressGet(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request for native SOL holdings only, without other tokens 
     * @summary holdings (native)
     * @param {DefaultApiHoldingsAddressNativeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public holdingsAddressNativeGet(requestParameters: DefaultApiHoldingsAddressNativeGetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).holdingsAddressNativeGet(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request for a base64-encoded unsigned swap transaction to be used in `POST /ultra/v1/execute` 
     * @summary order
     * @param {DefaultApiOrderGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderGet(requestParameters: DefaultApiOrderGetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).orderGet(requestParameters.inputMint, requestParameters.outputMint, requestParameters.amount, requestParameters.taker, requestParameters.receiver, requestParameters.payer, requestParameters.closeAuthority, requestParameters.referralAccount, requestParameters.referralFee, requestParameters.excludeRouters, requestParameters.excludeDexes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request for the list of routers available in the routing engine of Ultra, which is [Juno](/docs/routing#juno-liquidity-engine) 
     * @summary routers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public orderRoutersGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).orderRoutersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request a search by token\'s symbol, name or mint address 
     * @summary search
     * @param {DefaultApiSearchGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchGet(requestParameters: DefaultApiSearchGetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchGet(requestParameters.query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request for token information and warnings of mints 
     * @summary shield
     * @param {DefaultApiShieldGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public shieldGet(requestParameters: DefaultApiShieldGetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).shieldGet(requestParameters.mints, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const OrderGetExcludeRoutersEnum = {
    IRIS: 'iris',
    JUPITERZ: 'jupiterz',
    DFLOW: 'dflow',
    OKX: 'okx'
} as const;
export type OrderGetExcludeRoutersEnum = typeof OrderGetExcludeRoutersEnum[keyof typeof OrderGetExcludeRoutersEnum];
